<html>
    <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <title>Hammerspoon docs: hs.window.filter module</title>
    <style type="text/css">
      a { text-decoration: none; }
      a:hover { text-decoration: underline; }
      th { background-color: #DDDDDD; vertical-align: top; padding: 3px; }
      td { width: 100%; background-color: #EEEEEE; vertical-align: top; padding: 3px; }
      table { width: 100% ; border: 1px solid #0; text-align: left; }
    </style>
    <link rel="stylesheet" href="docs.css" type="text/css" media="screen" />
  </head>
  <body>
    <header>
      <h1><a href="./index.html">docs</a> &raquo; hs.window.filter</h1>
      <p><strong>WARNING</strong>: EXPERIMENTAL MODULE. DO <strong>NOT</strong> USE IN PRODUCTION.<br>
This module is <em>for testing purposes only</em>. It can undergo breaking API changes <strong>at any point and without notice</strong>.<br>
(Should you encounter any issues, please feel free to report them on <a href="https://github.com/Hammerspoon/hammerspoon/issues">https://github.com/Hammerspoon/hammerspoon/issues</a><br>
or #hammerspoon on irc.freenode.net)</p>

<p>Filter windows by application, title, location on screen and more, and easily subscribe to events on these windows</p>

<p>Windowfilters monitor all windows as they&#39;re created, closed, moved etc., and select some (or none) among these windows<br>
according to specific filtering rules. These filtering rules are app-specific, i.e. they start off by selecting all windows<br>
belonging to a certain application (but you can also define <em>default</em> and <em>override</em> filters - see <code>:setAppFilter()</code>,<br>
<code>:setDefaultFilter()</code>, <code>:setOverrideFilter()</code>) and they can allow or reject windows based on:</p>

<ul>
<li>visibility, focused and/or fullscreen status</li>
<li>title length or patterns in the title</li>
<li>position on screen (inside or outside a certain region or screen)</li>
<li>accessibility role (standard window, dialog, etc.)</li>
<li>whether they&#39;re in the current Mission Control Space or not</li>
</ul>

<p>The filtering happens automatically in the background; windowfilters then:</p>

<ul>
<li>generate a dynamic list of the windows that currently satisfy the filtering rules (see <code>:getWindows()</code>, <code>:notify()</code>)</li>
<li>sanitize and expose all pertinent events on these windows (see <code>:subscribe()</code> and the module constants with all the events)</li>
</ul>

<p>A <em>default windowfilter</em> (not to be confused with the default filter <em>within</em> a windowfilter) is provided as convenience;<br>
it excludes some known apps and windows that are transient in nature, therefore unlikely to be &quot;interesting&quot; for e.g. window management.<br>
<code>hs.window.filter.new()</code> (with no arguments) returns a copy of the default windowfilter that you can further tailor<br>
to your needs - see <code>hs.window.filter.default</code> and <code>hs.window.filter.new()</code> for more information.</p>

<p>Usage examples:</p>

<pre><code>-- alter the default windowfilter
hs.window.filter.default:setAppFilter(&#39;My IDE&#39;,{allowTitles=1}) -- ignore no-title windows (e.g. transient autocomplete suggestions) in My IDE

-- set the exact scope of what you&#39;re interested in - see hs.window.filter:setAppFilter()
wf_terminal = hs.window.filter.new{&#39;Terminal&#39;,&#39;iTerm2&#39;} -- all visible terminal windows
wf_timewaster = hs.window.filter.new(false):setAppFilter(&#39;Safari&#39;,{allowTitles=&#39;reddit&#39;}) -- any Safari windows with &quot;reddit&quot; anywhere in the title
wf_leftscreen = hs.window.filter.new{override={visible=true,fullscreen=false,allowScreens=&#39;-1,0&#39;,currentSpace=true}}
-- all visible and non-fullscreen windows that are on the screen to the left of the primary screen in the current Space
wf_editors_righthalf = hs.window.filter.new{&#39;TextEdit&#39;,&#39;Sublime Text&#39;,&#39;BBEdit&#39;}:setRegions(hs.screen.primaryScreen():fromUnitRect&#39;0.5,0/1,1&#39;)
-- text editor windows that are on the right half of the primary screen
wf_bigwindows = hs.window.filter.new(function(w)return w:frame().area&gt;3000000 end) -- only very large windows
wf_notif = hs.window.filter.new{[&#39;Notification Center&#39;]={allowRoles=&#39;AXNotificationCenterAlert&#39;}} -- notification center alerts

-- subscribe to events
wf_terminal:subscribe(hs.window.filter.windowFocused,some_fn) -- run a function whenever a terminal window is focused
wf_timewaster:notify(startAnnoyingMe,stopAnnoyingMe) -- fight procrastination :)
</code></pre>

      </header>
      <h3>API Overview</h3>
      <ul>
    
                <li>Constants - Useful values which cannot be changed</li>
                    <ul>
                
        <li><a href="#default">default</a></li>
        
        <li><a href="#sortByCreated">sortByCreated</a></li>
        
        <li><a href="#sortByCreatedLast">sortByCreatedLast</a></li>
        
        <li><a href="#sortByFocused">sortByFocused</a></li>
        
        <li><a href="#sortByFocusedLast">sortByFocusedLast</a></li>
        
        <li><a href="#windowCreated">windowCreated</a></li>
        
        <li><a href="#windowDestroyed">windowDestroyed</a></li>
        
        <li><a href="#windowFocused">windowFocused</a></li>
        
        <li><a href="#windowFullscreened">windowFullscreened</a></li>
        
        <li><a href="#windowHidden">windowHidden</a></li>
        
        <li><a href="#windowInCurrentSpace">windowInCurrentSpace</a></li>
        
        <li><a href="#windowMinimized">windowMinimized</a></li>
        
        <li><a href="#windowMoved">windowMoved</a></li>
        
        <li><a href="#windowNotInCurrentSpace">windowNotInCurrentSpace</a></li>
        
        <li><a href="#windowNotOnScreen">windowNotOnScreen</a></li>
        
        <li><a href="#windowNotVisible">windowNotVisible</a></li>
        
        <li><a href="#windowOnScreen">windowOnScreen</a></li>
        
        <li><a href="#windowTitleChanged">windowTitleChanged</a></li>
        
        <li><a href="#windowUnfocused">windowUnfocused</a></li>
        
        <li><a href="#windowUnfullscreened">windowUnfullscreened</a></li>
        
        <li><a href="#windowUnhidden">windowUnhidden</a></li>
        
        <li><a href="#windowUnminimized">windowUnminimized</a></li>
        
        <li><a href="#windowVisible">windowVisible</a></li>
        
                </ul>
                
                <li>Variables - Configurable values</li>
                    <ul>
                
        <li><a href="#allowedWindowRoles">allowedWindowRoles</a></li>
        
        <li><a href="#forceRefreshOnSpaceChange">forceRefreshOnSpaceChange</a></li>
        
        <li><a href="#ignoreAlways">ignoreAlways</a></li>
        
                </ul>
                
                <li>Functions - API calls offered directly by the extension</li>
                    <ul>
                
        <li><a href="#isGuiApp">isGuiApp</a></li>
        
        <li><a href="#switchedToSpace">switchedToSpace</a></li>
        
                </ul>
                
                <li>Constructors - API calls which return an object, typically one that offers API methods</li>
                    <ul>
                
        <li><a href="#copy">copy</a></li>
        
        <li><a href="#new">new</a></li>
        
                </ul>
                
                <li>Methods - API calls which can only be made on an object returned by a constructor</li>
                    <ul>
                
        <li><a href="#allowApp">allowApp</a></li>
        
        <li><a href="#focusWindowEast">focusWindowEast</a></li>
        
        <li><a href="#focusWindowNorth">focusWindowNorth</a></li>
        
        <li><a href="#focusWindowSouth">focusWindowSouth</a></li>
        
        <li><a href="#focusWindowWest">focusWindowWest</a></li>
        
        <li><a href="#getFilters">getFilters</a></li>
        
        <li><a href="#getWindows">getWindows</a></li>
        
        <li><a href="#isAppAllowed">isAppAllowed</a></li>
        
        <li><a href="#isWindowAllowed">isWindowAllowed</a></li>
        
        <li><a href="#notify">notify</a></li>
        
        <li><a href="#pause">pause</a></li>
        
        <li><a href="#rejectApp">rejectApp</a></li>
        
        <li><a href="#resume">resume</a></li>
        
        <li><a href="#setAppFilter">setAppFilter</a></li>
        
        <li><a href="#setCurrentSpace">setCurrentSpace</a></li>
        
        <li><a href="#setDefaultFilter">setDefaultFilter</a></li>
        
        <li><a href="#setFilters">setFilters</a></li>
        
        <li><a href="#setOverrideFilter">setOverrideFilter</a></li>
        
        <li><a href="#setRegions">setRegions</a></li>
        
        <li><a href="#setScreens">setScreens</a></li>
        
        <li><a href="#setSortOrder">setSortOrder</a></li>
        
        <li><a href="#subscribe">subscribe</a></li>
        
        <li><a href="#unsubscribe">unsubscribe</a></li>
        
        <li><a href="#unsubscribeAll">unsubscribeAll</a></li>
        
        <li><a href="#windowsToEast">windowsToEast</a></li>
        
        <li><a href="#windowsToNorth">windowsToNorth</a></li>
        
        <li><a href="#windowsToSouth">windowsToSouth</a></li>
        
        <li><a href="#windowsToWest">windowsToWest</a></li>
        
                </ul>
                
    </ul>
    <h3>API Documentation</h3>
    
                <h4 class="documentation-section">Constants</h4>
                

    <section id="default">
    <a name="//apple_ref/cpp/Constant/default" class="dashAnchor"></a>
    <h5><a href="#default">default</a></h5>
    <table>
        <tr>
            <th>Signature</td>
            <td><code>hs.window.filter.default</code></td>
        </tr>
        <tr>
            <th>Type</td>
            <td>Constant</td>
        </tr>
        <tr>
            <th>Description</td>
            <td>
                <p>The default windowfilter; it filters apps whose windows are transient in nature so that you&#39;re unlikely (and often<br>
unable) to do anything with them, such as launchers, menulets, preference pane apps, screensavers, etc. It also<br>
filters nonstandard and invisible windows.</p>

<p>Notes:</p>

<ul>
<li>While you can customize the default windowfilter, it&#39;s usually advisable to make your customizations on a local copy via <code>mywf=hs.window.filter.new()</code>;
the default windowfilter can potentially be used in several Hammerspoon modules and changing it might have unintended consequences.
Common customizations:

<ul>
<li>to exclude fullscreen windows: <code>nofs_wf=hs.window.filter.new():setOverrideFilter{fullscreen=false}</code></li>
<li>to include invisible windows: <code>inv_wf=windowfilter.new():setDefaultFilter{}</code></li>
</ul></li>
<li>If you still want to alter the default windowfilter:

<ul>
<li>you should probably apply your customizations at the top of your <code>init.lua</code>, or at any rate before instantiating any other windowfilter; this
way copies created via <code>hs.window.filter.new(nil,...)</code> will inherit your modifications</li>
<li>to list the known exclusions: <code>hs.inspect(hs.window.filter.default:getFilters())</code> from the console</li>
<li>to add an exclusion: <code>hs.window.filter.default:rejectApp&#39;Cool New Launcher&#39;</code></li>
<li>to add an app-specific rule: <code>hs.window.filter.default:setAppFilter(&#39;My IDE&#39;,1)</code>; ignore tooltips/code completion (empty title) in My IDE</li>
<li>to remove an exclusion (e.g. if you want to have access to Spotlight windows): <code>hs.window.filter.default:allowApp&#39;Spotlight&#39;</code>;
for specialized uses you can make a specific windowfilter with <code>myfilter=hs.window.filter.new&#39;Spotlight&#39;</code></li>
</ul></li>
</ul>

            </td>
        </tr>
    </table>
    </section>


    <section id="sortByCreated">
    <a name="//apple_ref/cpp/Constant/sortByCreated" class="dashAnchor"></a>
    <h5><a href="#sortByCreated">sortByCreated</a></h5>
    <table>
        <tr>
            <th>Signature</td>
            <td><code>hs.window.filter.sortByCreated</code></td>
        </tr>
        <tr>
            <th>Type</td>
            <td>Constant</td>
        </tr>
        <tr>
            <th>Description</td>
            <td>
                <p>Sort order for <code>hs.window.filter:getWindows()</code>: windows are sorted in order of creation, oldest first (see also <code>hs.window.filter:setSortOrder()</code>)</p>

            </td>
        </tr>
    </table>
    </section>


    <section id="sortByCreatedLast">
    <a name="//apple_ref/cpp/Constant/sortByCreatedLast" class="dashAnchor"></a>
    <h5><a href="#sortByCreatedLast">sortByCreatedLast</a></h5>
    <table>
        <tr>
            <th>Signature</td>
            <td><code>hs.window.filter.sortByCreatedLast</code></td>
        </tr>
        <tr>
            <th>Type</td>
            <td>Constant</td>
        </tr>
        <tr>
            <th>Description</td>
            <td>
                <p>Sort order for <code>hs.window.filter:getWindows()</code>: windows are sorted in order of creation, newest first (see also <code>hs.window.filter:setSortOrder()</code>)</p>

            </td>
        </tr>
    </table>
    </section>


    <section id="sortByFocused">
    <a name="//apple_ref/cpp/Constant/sortByFocused" class="dashAnchor"></a>
    <h5><a href="#sortByFocused">sortByFocused</a></h5>
    <table>
        <tr>
            <th>Signature</td>
            <td><code>hs.window.filter.sortByFocused</code></td>
        </tr>
        <tr>
            <th>Type</td>
            <td>Constant</td>
        </tr>
        <tr>
            <th>Description</td>
            <td>
                <p>Sort order for <code>hs.window.filter:getWindows()</code>: windows are sorted in order of focus received, least recently first (see also <code>hs.window.filter:setSortOrder()</code>)</p>

            </td>
        </tr>
    </table>
    </section>


    <section id="sortByFocusedLast">
    <a name="//apple_ref/cpp/Constant/sortByFocusedLast" class="dashAnchor"></a>
    <h5><a href="#sortByFocusedLast">sortByFocusedLast</a></h5>
    <table>
        <tr>
            <th>Signature</td>
            <td><code>hs.window.filter.sortByFocusedLast</code></td>
        </tr>
        <tr>
            <th>Type</td>
            <td>Constant</td>
        </tr>
        <tr>
            <th>Description</td>
            <td>
                <p>Sort order for <code>hs.window.filter:getWindows()</code>: windows are sorted in order of focus received, most recently first (see also <code>hs.window.filter:setSortOrder()</code>)</p>

<p>Notes:</p>

<ul>
<li>This is the default sort order for all windowfilters</li>
</ul>

            </td>
        </tr>
    </table>
    </section>


    <section id="windowCreated">
    <a name="//apple_ref/cpp/Constant/windowCreated" class="dashAnchor"></a>
    <h5><a href="#windowCreated">windowCreated</a></h5>
    <table>
        <tr>
            <th>Signature</td>
            <td><code>hs.window.filter.windowCreated</code></td>
        </tr>
        <tr>
            <th>Type</td>
            <td>Constant</td>
        </tr>
        <tr>
            <th>Description</td>
            <td>
                <p>Event for <code>hs.window.filter:subscribe()</code>: a new window was created</p>

            </td>
        </tr>
    </table>
    </section>


    <section id="windowDestroyed">
    <a name="//apple_ref/cpp/Constant/windowDestroyed" class="dashAnchor"></a>
    <h5><a href="#windowDestroyed">windowDestroyed</a></h5>
    <table>
        <tr>
            <th>Signature</td>
            <td><code>hs.window.filter.windowDestroyed</code></td>
        </tr>
        <tr>
            <th>Type</td>
            <td>Constant</td>
        </tr>
        <tr>
            <th>Description</td>
            <td>
                <p>Event for <code>hs.window.filter:subscribe()</code>: a window was destroyed</p>

            </td>
        </tr>
    </table>
    </section>


    <section id="windowFocused">
    <a name="//apple_ref/cpp/Constant/windowFocused" class="dashAnchor"></a>
    <h5><a href="#windowFocused">windowFocused</a></h5>
    <table>
        <tr>
            <th>Signature</td>
            <td><code>hs.window.filter.windowFocused</code></td>
        </tr>
        <tr>
            <th>Type</td>
            <td>Constant</td>
        </tr>
        <tr>
            <th>Description</td>
            <td>
                <p>Event for <code>hs.window.filter:subscribe()</code>: a window received focus</p>

            </td>
        </tr>
    </table>
    </section>


    <section id="windowFullscreened">
    <a name="//apple_ref/cpp/Constant/windowFullscreened" class="dashAnchor"></a>
    <h5><a href="#windowFullscreened">windowFullscreened</a></h5>
    <table>
        <tr>
            <th>Signature</td>
            <td><code>hs.window.filter.windowFullscreened</code></td>
        </tr>
        <tr>
            <th>Type</td>
            <td>Constant</td>
        </tr>
        <tr>
            <th>Description</td>
            <td>
                <p>Event for <code>hs.window.filter:subscribe()</code>: a window was expanded to fullscreen</p>

            </td>
        </tr>
    </table>
    </section>


    <section id="windowHidden">
    <a name="//apple_ref/cpp/Constant/windowHidden" class="dashAnchor"></a>
    <h5><a href="#windowHidden">windowHidden</a></h5>
    <table>
        <tr>
            <th>Signature</td>
            <td><code>hs.window.filter.windowHidden</code></td>
        </tr>
        <tr>
            <th>Type</td>
            <td>Constant</td>
        </tr>
        <tr>
            <th>Description</td>
            <td>
                <p>Event for <code>hs.window.filter:subscribe()</code>: a window was hidden (its app was hidden, e.g. via <code>cmd-h</code>)</p>

            </td>
        </tr>
    </table>
    </section>


    <section id="windowInCurrentSpace">
    <a name="//apple_ref/cpp/Constant/windowInCurrentSpace" class="dashAnchor"></a>
    <h5><a href="#windowInCurrentSpace">windowInCurrentSpace</a></h5>
    <table>
        <tr>
            <th>Signature</td>
            <td><code>hs.window.filter.windowInCurrentSpace</code></td>
        </tr>
        <tr>
            <th>Type</td>
            <td>Constant</td>
        </tr>
        <tr>
            <th>Description</td>
            <td>
                <p>Event for <code>hs.window.filter:subscribe()</code>: a window is now in the current Mission Control Space, due to<br>
a Space switch or because it was hidden or minimized (hidden and minimized windows belong to all Spaces)</p>

            </td>
        </tr>
    </table>
    </section>


    <section id="windowMinimized">
    <a name="//apple_ref/cpp/Constant/windowMinimized" class="dashAnchor"></a>
    <h5><a href="#windowMinimized">windowMinimized</a></h5>
    <table>
        <tr>
            <th>Signature</td>
            <td><code>hs.window.filter.windowMinimized</code></td>
        </tr>
        <tr>
            <th>Type</td>
            <td>Constant</td>
        </tr>
        <tr>
            <th>Description</td>
            <td>
                <p>Event for <code>hs.window.filter:subscribe()</code>: a window was minimized</p>

            </td>
        </tr>
    </table>
    </section>


    <section id="windowMoved">
    <a name="//apple_ref/cpp/Constant/windowMoved" class="dashAnchor"></a>
    <h5><a href="#windowMoved">windowMoved</a></h5>
    <table>
        <tr>
            <th>Signature</td>
            <td><code>hs.window.filter.windowMoved</code></td>
        </tr>
        <tr>
            <th>Type</td>
            <td>Constant</td>
        </tr>
        <tr>
            <th>Description</td>
            <td>
                <p>Event for <code>hs.window.filter:subscribe()</code>: a window was moved or resized, including toggling fullscreen/maximize</p>

            </td>
        </tr>
    </table>
    </section>


    <section id="windowNotInCurrentSpace">
    <a name="//apple_ref/cpp/Constant/windowNotInCurrentSpace" class="dashAnchor"></a>
    <h5><a href="#windowNotInCurrentSpace">windowNotInCurrentSpace</a></h5>
    <table>
        <tr>
            <th>Signature</td>
            <td><code>hs.window.filter.windowNotInCurrentSpace</code></td>
        </tr>
        <tr>
            <th>Type</td>
            <td>Constant</td>
        </tr>
        <tr>
            <th>Description</td>
            <td>
                <p>Event for <code>hs.window.filter:subscribe()</code>: a window that used to be in the current Mission Control Space isn&#39;t anymore,<br>
due to a Space switch or because it was unhidden or unminimized onto another Space</p>

            </td>
        </tr>
    </table>
    </section>


    <section id="windowNotOnScreen">
    <a name="//apple_ref/cpp/Constant/windowNotOnScreen" class="dashAnchor"></a>
    <h5><a href="#windowNotOnScreen">windowNotOnScreen</a></h5>
    <table>
        <tr>
            <th>Signature</td>
            <td><code>hs.window.filter.windowNotOnScreen</code></td>
        </tr>
        <tr>
            <th>Type</td>
            <td>Constant</td>
        </tr>
        <tr>
            <th>Description</td>
            <td>
                <p>Event for <code>hs.window.filter:subscribe()</code>: a window is no longer <em>actually</em> visible on any screen because it was minimized, closed,<br>
its application was hidden (e.g. via cmd-h) or closed, or because it&#39;s not in the current Mission Control Space anymore</p>

            </td>
        </tr>
    </table>
    </section>


    <section id="windowNotVisible">
    <a name="//apple_ref/cpp/Constant/windowNotVisible" class="dashAnchor"></a>
    <h5><a href="#windowNotVisible">windowNotVisible</a></h5>
    <table>
        <tr>
            <th>Signature</td>
            <td><code>hs.window.filter.windowNotVisible</code></td>
        </tr>
        <tr>
            <th>Type</td>
            <td>Constant</td>
        </tr>
        <tr>
            <th>Description</td>
            <td>
                <p>Event for <code>hs.window.filter:subscribe()</code>: a window is no longer &quot;visible&quot; (in <em>any</em> Mission Control Space, as per <code>hs.window:isVisible()</code>)<br>
because it was minimized or closed, or its application was hidden (e.g. via <code>cmd-h</code>) or closed</p>

            </td>
        </tr>
    </table>
    </section>


    <section id="windowOnScreen">
    <a name="//apple_ref/cpp/Constant/windowOnScreen" class="dashAnchor"></a>
    <h5><a href="#windowOnScreen">windowOnScreen</a></h5>
    <table>
        <tr>
            <th>Signature</td>
            <td><code>hs.window.filter.windowOnScreen</code></td>
        </tr>
        <tr>
            <th>Type</td>
            <td>Constant</td>
        </tr>
        <tr>
            <th>Description</td>
            <td>
                <p>Event for <code>hs.window.filter:subscribe()</code>: a window became <em>actually</em> visible on screen (i.e. it&#39;s &quot;visible&quot; as per <code>hs.window:isVisible()</code><br>
<em>and</em> in the current Mission Control Space) after having been not visible, or when created</p>

            </td>
        </tr>
    </table>
    </section>


    <section id="windowTitleChanged">
    <a name="//apple_ref/cpp/Constant/windowTitleChanged" class="dashAnchor"></a>
    <h5><a href="#windowTitleChanged">windowTitleChanged</a></h5>
    <table>
        <tr>
            <th>Signature</td>
            <td><code>hs.window.filter.windowTitleChanged</code></td>
        </tr>
        <tr>
            <th>Type</td>
            <td>Constant</td>
        </tr>
        <tr>
            <th>Description</td>
            <td>
                <p>Event for <code>hs.window.filter:subscribe()</code>: a window&#39;s title changed</p>

            </td>
        </tr>
    </table>
    </section>


    <section id="windowUnfocused">
    <a name="//apple_ref/cpp/Constant/windowUnfocused" class="dashAnchor"></a>
    <h5><a href="#windowUnfocused">windowUnfocused</a></h5>
    <table>
        <tr>
            <th>Signature</td>
            <td><code>hs.window.filter.windowUnfocused</code></td>
        </tr>
        <tr>
            <th>Type</td>
            <td>Constant</td>
        </tr>
        <tr>
            <th>Description</td>
            <td>
                <p>Event for <code>hs.window.filter:subscribe()</code>: a window lost focus</p>

            </td>
        </tr>
    </table>
    </section>


    <section id="windowUnfullscreened">
    <a name="//apple_ref/cpp/Constant/windowUnfullscreened" class="dashAnchor"></a>
    <h5><a href="#windowUnfullscreened">windowUnfullscreened</a></h5>
    <table>
        <tr>
            <th>Signature</td>
            <td><code>hs.window.filter.windowUnfullscreened</code></td>
        </tr>
        <tr>
            <th>Type</td>
            <td>Constant</td>
        </tr>
        <tr>
            <th>Description</td>
            <td>
                <p>Event for <code>hs.window.filter:subscribe()</code>: a window was reverted back from fullscreen</p>

            </td>
        </tr>
    </table>
    </section>


    <section id="windowUnhidden">
    <a name="//apple_ref/cpp/Constant/windowUnhidden" class="dashAnchor"></a>
    <h5><a href="#windowUnhidden">windowUnhidden</a></h5>
    <table>
        <tr>
            <th>Signature</td>
            <td><code>hs.window.filter.windowUnhidden</code></td>
        </tr>
        <tr>
            <th>Type</td>
            <td>Constant</td>
        </tr>
        <tr>
            <th>Description</td>
            <td>
                <p>Event for <code>hs.window.filter:subscribe()</code>: a window was unhidden (its app was unhidden, e.g. via <code>cmd-h</code>)</p>

            </td>
        </tr>
    </table>
    </section>


    <section id="windowUnminimized">
    <a name="//apple_ref/cpp/Constant/windowUnminimized" class="dashAnchor"></a>
    <h5><a href="#windowUnminimized">windowUnminimized</a></h5>
    <table>
        <tr>
            <th>Signature</td>
            <td><code>hs.window.filter.windowUnminimized</code></td>
        </tr>
        <tr>
            <th>Type</td>
            <td>Constant</td>
        </tr>
        <tr>
            <th>Description</td>
            <td>
                <p>Event for <code>hs.window.filter:subscribe()</code>: a window was unminimized</p>

            </td>
        </tr>
    </table>
    </section>


    <section id="windowVisible">
    <a name="//apple_ref/cpp/Constant/windowVisible" class="dashAnchor"></a>
    <h5><a href="#windowVisible">windowVisible</a></h5>
    <table>
        <tr>
            <th>Signature</td>
            <td><code>hs.window.filter.windowVisible</code></td>
        </tr>
        <tr>
            <th>Type</td>
            <td>Constant</td>
        </tr>
        <tr>
            <th>Description</td>
            <td>
                <p>Event for <code>hs.window.filter:subscribe()</code>: a window became &quot;visible&quot; (in <em>any</em> Mission Control Space, as per <code>hs.window:isVisible()</code>)<br>
after having been hidden or minimized, or if it was just created</p>

            </td>
        </tr>
    </table>
    </section>

                <h4 class="documentation-section">Variables</h4>
                

    <section id="allowedWindowRoles">
    <a name="//apple_ref/cpp/Variable/allowedWindowRoles" class="dashAnchor"></a>
    <h5><a href="#allowedWindowRoles">allowedWindowRoles</a></h5>
    <table>
        <tr>
            <th>Signature</td>
            <td><code>hs.window.filter.allowedWindowRoles</code></td>
        </tr>
        <tr>
            <th>Type</td>
            <td>Variable</td>
        </tr>
        <tr>
            <th>Description</td>
            <td>
                <p>A table for window roles (as per <code>hs.window:subrole()</code>) that are allowed by default.</p>

<p>Set the desired window roles as <em>keys</em> in this table, like this: <code>hs.window.filter.allowedWindowRoles = {AXStandardWindow=true,AXDialog=true}</code></p>

<p>Notes:</p>

<ul>
<li>You can have fine grained control of allowed window roles via the <code>setAppFilter</code>, <code>setDefaultFilter</code>, <code>setOverrideFilter</code> methods.</li>
<li>If you know what you&#39;re doing you can override the allowed window roles globally by changing this variable, but this is discouraged.</li>
</ul>

            </td>
        </tr>
    </table>
    </section>


    <section id="forceRefreshOnSpaceChange">
    <a name="//apple_ref/cpp/Variable/forceRefreshOnSpaceChange" class="dashAnchor"></a>
    <h5><a href="#forceRefreshOnSpaceChange">forceRefreshOnSpaceChange</a></h5>
    <table>
        <tr>
            <th>Signature</td>
            <td><code>hs.window.filter.forceRefreshOnSpaceChange</code></td>
        </tr>
        <tr>
            <th>Type</td>
            <td>Variable</td>
        </tr>
        <tr>
            <th>Description</td>
            <td>
                <p>Tells all windowfilters whether to refresh all windows when the user switches to a different Mission Control Space.</p>

<p>Due to OS X limitations Hammerspoon cannot directly query for windows in Spaces other than the current one;<br>
therefore when a windowfilter is initially instantiated, it doesn&#39;t know about many of these windows.</p>

<p>If this variable is set to <code>true</code>, windowfilters will re-query applications for all their windows whenever a Space change<br>
by the user is detected, therefore any existing windows in that Space that were not yet being tracked will become known at that point;<br>
if <code>false</code> (the default) this won&#39;t happen, but the windowfilters will <em>eventually</em> learn about these windows<br>
anyway, as soon as they&#39;re interacted with.</p>

<p>If you need your windowfilters to become aware of windows across all Spaces as soon as possible, you can set this to <code>true</code>,<br>
but you&#39;ll incur a modest performance penalty on every Space change. If possible, use the <code>hs.window.filter.switchedToSpace()</code><br>
callback instead.</p>

<p>Notes:</p>

<ul>
<li>If you defined one or more Spaces-aware windowfilters (i.e. when the <code>currentSpace</code> field of a filter
is present), windows need refreshing at every space change anyway, so this variable is ignored</li>
</ul>

            </td>
        </tr>
    </table>
    </section>


    <section id="ignoreAlways">
    <a name="//apple_ref/cpp/Variable/ignoreAlways" class="dashAnchor"></a>
    <h5><a href="#ignoreAlways">ignoreAlways</a></h5>
    <table>
        <tr>
            <th>Signature</td>
            <td><code>hs.window.filter.ignoreAlways</code></td>
        </tr>
        <tr>
            <th>Type</td>
            <td>Variable</td>
        </tr>
        <tr>
            <th>Description</td>
            <td>
                <p>A table of application names (as per <code>hs.application:name()</code>) that are always ignored by this module.<br>
These are apps with no windows or any visible GUI, such as system services, background daemons and &quot;helper&quot; apps.</p>

<p>You can add an app to this table with <code>hs.window.filter.ignoreAlways[&#39;Background App Title&#39;] = true</code></p>

<p>Notes:</p>

<ul>
<li>As the name implies, even the empty, &quot;allow all&quot; windowfilter will ignore these apps.</li>
<li>You don&#39;t <em>need</em> to keep this table up to date, since non GUI apps will simply never show up anywhere;
this table is just used as a &quot;root&quot; filter to gain a (very small) performance improvement.</li>
</ul>

            </td>
        </tr>
    </table>
    </section>

                <h4 class="documentation-section">Functions</h4>
                

    <section id="isGuiApp">
    <a name="//apple_ref/cpp/Function/isGuiApp" class="dashAnchor"></a>
    <h5><a href="#isGuiApp">isGuiApp</a></h5>
    <table>
        <tr>
            <th>Signature</td>
            <td><code>hs.window.filter.isGuiApp(appname) -> boolean</code></td>
        </tr>
        <tr>
            <th>Type</td>
            <td>Function</td>
        </tr>
        <tr>
            <th>Description</td>
            <td>
                <p>Checks whether an app is a known non-GUI app, as per <code>hs.window.filter.ignoreAlways</code></p>

<p>Parameters:</p>

<ul>
<li>appname - name of the app to check as per <code>hs.application:name()</code></li>
</ul>

<p>Returns:</p>

<ul>
<li><code>false</code> if the app is a known non-GUI (or not accessible) app; <code>true</code> otherwise</li>
</ul>

            </td>
        </tr>
    </table>
    </section>


    <section id="switchedToSpace">
    <a name="//apple_ref/cpp/Function/switchedToSpace" class="dashAnchor"></a>
    <h5><a href="#switchedToSpace">switchedToSpace</a></h5>
    <table>
        <tr>
            <th>Signature</td>
            <td><code>hs.window.filter.switchedToSpace(space)</code></td>
        </tr>
        <tr>
            <th>Type</td>
            <td>Function</td>
        </tr>
        <tr>
            <th>Description</td>
            <td>
                <p>Callback to inform all windowfilters that the user initiated a switch to a (numbered) Mission Control Space.</p>

<p>See <code>hs.window.filter.forceRefreshOnSpaceChange</code> for an overview of Spaces limitations in Hammerspoon. If you<br>
often (or always) change Space via the &quot;numbered&quot; Mission Control keyboard shortcuts (by default, <code>ctrl-1</code> etc.), you<br>
can call this function from your <code>init.lua</code> when intercepting these shortcuts; for example:</p>

<pre><code>hs.hotkey.bind(&#39;ctrl&#39;,&#39;1&#39;,nil,function()hs.window.filter.switchedToSpace(1)end)
hs.hotkey.bind(&#39;ctrl&#39;,&#39;2&#39;,nil,function()hs.window.filter.switchedToSpace(2)end)
-- etc.
</code></pre>

<p>Using this callback results in slightly better performance than setting <code>forceRefreshOnSpaceChange</code> to <code>true</code>, since<br>
already visited Spaces are remembered and no refreshing is necessary when switching back to those.</p>

<p>Parameters:</p>

<ul>
<li>space - the Space number the user is switching to</li>
</ul>

<p>Returns:</p>

<ul>
<li>None</li>
</ul>

<p>Notes:</p>

<ul>
<li>Only use this function if &quot;Displays have separate Spaces&quot; and &quot;Automatically rearrange Spaces&quot; are
OFF in System Preferences&gt;Mission Control</li>
<li>Calling this function will set <code>hs.window.filter.forceRefreshOnSpaceChange</code> to <code>false</code></li>
<li>If you defined one or more Spaces-aware windowfilters (i.e. when the <code>currentSpace</code> field of a filter
is present), windows need refreshing at every space change anyway, so using this callback will not
result in improved performance</li>
</ul>

            </td>
        </tr>
    </table>
    </section>

                <h4 class="documentation-section">Constructors</h4>
                

    <section id="copy">
    <a name="//apple_ref/cpp/Constructor/copy" class="dashAnchor"></a>
    <h5><a href="#copy">copy</a></h5>
    <table>
        <tr>
            <th>Signature</td>
            <td><code>hs.window.filter.copy(windowfilter[,logname[,loglevel]]) -> hs.window.filter object</code></td>
        </tr>
        <tr>
            <th>Type</td>
            <td>Constructor</td>
        </tr>
        <tr>
            <th>Description</td>
            <td>
                <p>Returns a copy of an hs.window.filter object that you can further restrict or expand</p>

<p>Parameters:</p>

<ul>
<li>windowfilter - an <code>hs.window.filter</code> object to copy</li>
<li>logname - (optional) name of the <code>hs.logger</code> instance for the new windowfilter; if omitted, the class logger will be used</li>
<li>loglevel - (optional) log level for the <code>hs.logger</code> instance for the new windowfilter</li>
</ul>

            </td>
        </tr>
    </table>
    </section>


    <section id="new">
    <a name="//apple_ref/cpp/Constructor/new" class="dashAnchor"></a>
    <h5><a href="#new">new</a></h5>
    <table>
        <tr>
            <th>Signature</td>
            <td><code>hs.window.filter.new(fn[,logname[,loglevel]]) -> hs.window.filter object</code></td>
        </tr>
        <tr>
            <th>Type</td>
            <td>Constructor</td>
        </tr>
        <tr>
            <th>Description</td>
            <td>
                <p>Creates a new hs.window.filter instance</p>

<p>Parameters:</p>

<ul>
<li>fn

<ul>
<li>if <code>nil</code>, returns a copy of the default windowfilter, including any customizations you might have applied to it
so far; you can then further restrict or expand it</li>
<li>if <code>true</code>, returns an empty windowfilter that allows every window</li>
<li>if <code>false</code>, returns a windowfilter with a default rule to reject every window</li>
<li>if a string or table of strings, returns a windowfilter that only allows visible windows of the specified apps
as per <code>hs.application:name()</code></li>
<li>if a table, you can fully define a windowfilter without having to call any methods after construction; the
table must be structured as per <code>hs.window.filter:setFilters()</code>; if not specified in the table, the
default filter in the new windowfilter will reject all windows</li>
<li>otherwise it must be a function that accepts an <code>hs.window</code> object and returns <code>true</code> if the window is allowed
or <code>false</code> otherwise; this way you can define a fully custom windowfilter</li>
</ul></li>
<li>logname - (optional) name of the <code>hs.logger</code> instance for the new windowfilter; if omitted, the class logger will be used</li>
<li>loglevel - (optional) log level for the <code>hs.logger</code> instance for the new windowfilter</li>
</ul>

<p>Returns:</p>

<ul>
<li>a new windowfilter instance</li>
</ul>

            </td>
        </tr>
    </table>
    </section>

                <h4 class="documentation-section">Methods</h4>
                

    <section id="allowApp">
    <a name="//apple_ref/cpp/Method/allowApp" class="dashAnchor"></a>
    <h5><a href="#allowApp">allowApp</a></h5>
    <table>
        <tr>
            <th>Signature</td>
            <td><code>hs.window.filter:allowApp(appname) -> hs.window.filter object</code></td>
        </tr>
        <tr>
            <th>Type</td>
            <td>Method</td>
        </tr>
        <tr>
            <th>Description</td>
            <td>
                <p>Sets the windowfilter to allow all visible windows belonging to a specific app</p>

<p>Parameters:</p>

<ul>
<li>appname - app name as per <code>hs.application:name()</code></li>
</ul>

<p>Returns:</p>

<ul>
<li>the <code>hs.window.filter</code> object for method chaining</li>
</ul>

<p>Notes:</p>

<ul>
<li>this is just a convenience wrapper for <code>windowfilter:setAppFilter(appname,{visible=true})</code></li>
</ul>

            </td>
        </tr>
    </table>
    </section>


    <section id="focusWindowEast">
    <a name="//apple_ref/cpp/Method/focusWindowEast" class="dashAnchor"></a>
    <h5><a href="#focusWindowEast">focusWindowEast</a></h5>
    <table>
        <tr>
            <th>Signature</td>
            <td><code>hs.window.filter:focusWindowEast(window, frontmost, strict)</code></td>
        </tr>
        <tr>
            <th>Type</td>
            <td>Method</td>
        </tr>
        <tr>
            <th>Description</td>
            <td>
                <p>Focuses the nearest window to the east of a given window</p>

<p>Parameters:</p>

<ul>
<li>window - (optional) an <code>hs.window</code> object; if nil, <code>hs.window.frontmostWindow()</code> will be used</li>
<li>frontmost - (optional) boolean, if true focuses the nearest window that isn&#39;t occluded by any other window in this windowfilter</li>
<li>strict - (optional) boolean, if true only consider windows at an angle between 45° and -45° on the
eastward axis</li>
</ul>

<p>Returns:</p>

<ul>
<li>None</li>
</ul>

<p>Notes:</p>

<ul>
<li>This is a convenience wrapper that performs <code>hs.window.focusWindowEast(window,self:getWindows(),...)</code></li>
<li>You&#39;ll likely want to add <code>:setCurrentSpace(true)</code> to the windowfilter used for this method call.</li>
</ul>

            </td>
        </tr>
    </table>
    </section>


    <section id="focusWindowNorth">
    <a name="//apple_ref/cpp/Method/focusWindowNorth" class="dashAnchor"></a>
    <h5><a href="#focusWindowNorth">focusWindowNorth</a></h5>
    <table>
        <tr>
            <th>Signature</td>
            <td><code>hs.window.filter:focusWindowNorth(window, frontmost, strict)</code></td>
        </tr>
        <tr>
            <th>Type</td>
            <td>Method</td>
        </tr>
        <tr>
            <th>Description</td>
            <td>
                <p>Focuses the nearest window to the south of a given window</p>

<p>Parameters:</p>

<ul>
<li>window - (optional) an <code>hs.window</code> object; if nil, <code>hs.window.frontmostWindow()</code> will be used</li>
<li>frontmost - (optional) boolean, if true focuses the nearest window that isn&#39;t occluded by any other window in this windowfilter</li>
<li>strict - (optional) boolean, if true only consider windows at an angle between 45° and -45° on the
southward axis</li>
</ul>

<p>Returns:</p>

<ul>
<li>None</li>
</ul>

<p>Notes:</p>

<ul>
<li>This is a convenience wrapper that performs <code>hs.window.focusWindowNorth(window,self:getWindows(),...)</code></li>
<li>You&#39;ll likely want to add <code>:setCurrentSpace(true)</code> to the windowfilter used for this method call.</li>
</ul>

            </td>
        </tr>
    </table>
    </section>


    <section id="focusWindowSouth">
    <a name="//apple_ref/cpp/Method/focusWindowSouth" class="dashAnchor"></a>
    <h5><a href="#focusWindowSouth">focusWindowSouth</a></h5>
    <table>
        <tr>
            <th>Signature</td>
            <td><code>hs.window.filter:focusWindowSouth(window, frontmost, strict)</code></td>
        </tr>
        <tr>
            <th>Type</td>
            <td>Method</td>
        </tr>
        <tr>
            <th>Description</td>
            <td>
                <p>Focuses the nearest window to the north of a given window</p>

<p>Parameters:</p>

<ul>
<li>window - (optional) an <code>hs.window</code> object; if nil, <code>hs.window.frontmostWindow()</code> will be used</li>
<li>frontmost - (optional) boolean, if true focuses the nearest window that isn&#39;t occluded by any other window in this windowfilter</li>
<li>strict - (optional) boolean, if true only consider windows at an angle between 45° and -45° on the
northward axis</li>
</ul>

<p>Returns:</p>

<ul>
<li>None</li>
</ul>

<p>Notes:</p>

<ul>
<li>This is a convenience wrapper that performs <code>hs.window.focusWindowSouth(window,self:getWindows(),...)</code></li>
<li>You&#39;ll likely want to add <code>:setCurrentSpace(true)</code> to the windowfilter used for this method call.</li>
</ul>

            </td>
        </tr>
    </table>
    </section>


    <section id="focusWindowWest">
    <a name="//apple_ref/cpp/Method/focusWindowWest" class="dashAnchor"></a>
    <h5><a href="#focusWindowWest">focusWindowWest</a></h5>
    <table>
        <tr>
            <th>Signature</td>
            <td><code>hs.window.filter:focusWindowWest(window, frontmost, strict)</code></td>
        </tr>
        <tr>
            <th>Type</td>
            <td>Method</td>
        </tr>
        <tr>
            <th>Description</td>
            <td>
                <p>Focuses the nearest window to the west of a given window</p>

<p>Parameters:</p>

<ul>
<li>window - (optional) an <code>hs.window</code> object; if nil, <code>hs.window.frontmostWindow()</code> will be used</li>
<li>frontmost - (optional) boolean, if true focuses the nearest window that isn&#39;t occluded by any other window in this windowfilter</li>
<li>strict - (optional) boolean, if true only consider windows at an angle between 45° and -45° on the
westward axis</li>
</ul>

<p>Returns:</p>

<ul>
<li>None</li>
</ul>

<p>Notes:</p>

<ul>
<li>This is a convenience wrapper that performs <code>hs.window.focusWindowWest(window,self:getWindows(),...)</code></li>
<li>You&#39;ll likely want to add <code>:setCurrentSpace(true)</code> to the windowfilter used for this method call.</li>
</ul>

            </td>
        </tr>
    </table>
    </section>


    <section id="getFilters">
    <a name="//apple_ref/cpp/Method/getFilters" class="dashAnchor"></a>
    <h5><a href="#getFilters">getFilters</a></h5>
    <table>
        <tr>
            <th>Signature</td>
            <td><code>hs.window.filter:getFilters() -> table</code></td>
        </tr>
        <tr>
            <th>Type</td>
            <td>Method</td>
        </tr>
        <tr>
            <th>Description</td>
            <td>
                <p>Return a table with all the filtering rules defined for this windowfilter</p>

<p>Parameters:</p>

<ul>
<li>None</li>
</ul>

<p>Returns:</p>

<ul>
<li>a table containing the filtering rules of this windowfilter; you can pass this table (optionally
after performing valid manipulations) to <code>hs.window.filter:setFilters()</code> and <code>hs.window.filter.new()</code></li>
</ul>

            </td>
        </tr>
    </table>
    </section>


    <section id="getWindows">
    <a name="//apple_ref/cpp/Method/getWindows" class="dashAnchor"></a>
    <h5><a href="#getWindows">getWindows</a></h5>
    <table>
        <tr>
            <th>Signature</td>
            <td><code>hs.window.filter:getWindows([sortOrder]) -> list of hs.window objects</code></td>
        </tr>
        <tr>
            <th>Type</td>
            <td>Method</td>
        </tr>
        <tr>
            <th>Description</td>
            <td>
                <p>Gets the current windows allowed by this windowfilter</p>

<p>Parameters:</p>

<ul>
<li>sortOrder - (optional) one of the <code>hs.window.filter.sortBy...</code> constants to determine the sort order
of the returned list; if omitted, uses the windowfilter&#39;s sort order as per <code>hs.window.filter:setSortOrder()</code>
(defaults to <code>sortByFocusedLast</code>)</li>
</ul>

<p>Returns:</p>

<ul>
<li>a list of <code>hs.window</code> objects</li>
</ul>

            </td>
        </tr>
    </table>
    </section>


    <section id="isAppAllowed">
    <a name="//apple_ref/cpp/Method/isAppAllowed" class="dashAnchor"></a>
    <h5><a href="#isAppAllowed">isAppAllowed</a></h5>
    <table>
        <tr>
            <th>Signature</td>
            <td><code>hs.window.filter:isAppAllowed(appname) -> boolean</code></td>
        </tr>
        <tr>
            <th>Type</td>
            <td>Method</td>
        </tr>
        <tr>
            <th>Description</td>
            <td>
                <p>Checks if an app is allowed by the windowfilter</p>

<p>Parameters:</p>

<ul>
<li>appname - app name as per <code>hs.application:name()</code></li>
</ul>

<p>Returns:</p>

<ul>
<li><code>false</code> if the app is rejected by the windowfilter; <code>true</code> otherwise</li>
</ul>

            </td>
        </tr>
    </table>
    </section>


    <section id="isWindowAllowed">
    <a name="//apple_ref/cpp/Method/isWindowAllowed" class="dashAnchor"></a>
    <h5><a href="#isWindowAllowed">isWindowAllowed</a></h5>
    <table>
        <tr>
            <th>Signature</td>
            <td><code>hs.window.filter:isWindowAllowed(window) -> boolean</code></td>
        </tr>
        <tr>
            <th>Type</td>
            <td>Method</td>
        </tr>
        <tr>
            <th>Description</td>
            <td>
                <p>Checks if a window is allowed by the windowfilter</p>

<p>Parameters:</p>

<ul>
<li>window - an <code>hs.window</code> object to check</li>
</ul>

<p>Returns:</p>

<ul>
<li><code>true</code> if the window is allowed by the windowfilter, <code>false</code> otherwise; <code>nil</code> if an invalid object was passed</li>
</ul>

            </td>
        </tr>
    </table>
    </section>


    <section id="notify">
    <a name="//apple_ref/cpp/Method/notify" class="dashAnchor"></a>
    <h5><a href="#notify">notify</a></h5>
    <table>
        <tr>
            <th>Signature</td>
            <td><code>hs.window.filter:notify(fn[, fnEmpty][, immediate]) -> hs.window.filter object</code></td>
        </tr>
        <tr>
            <th>Type</td>
            <td>Method</td>
        </tr>
        <tr>
            <th>Description</td>
            <td>
                <p>Notify a callback whenever the list of allowed windows change</p>

<p>Parameters:</p>

<ul>
<li>fn - a callback function that will be called when:

<ul>
<li>an allowed window is created or destroyed, and therefore added or removed from the list of allowed windows</li>
<li>a previously allowed window is now filtered or vice versa (e.g. in consequence of a title or position change)
It will be passed 2 parameters:</li>
<li>a list of the <code>hs.window</code> objects currently (i.e. <em>after</em> the change took place) allowed by this
windowfilter as per <code>hs.window.filter:getWindows()</code> (sorted according to <code>hs.window.filter:setSortOrder()</code>)</li>
<li>a string containing the (first) event that caused the change (see the <code>hs.window.filter.window...</code> event constants)</li>
</ul></li>
<li>fnEmpty - (optional) if provided, when this windowfilter becomes empty (i.e. <code>:getWindows()</code> returns
an empty list) call this function (with no arguments) instead of <code>fn</code>, otherwise, always call <code>fn</code></li>
<li>immediate - (optional) if <code>true</code>, also call <code>fn</code> (or <code>fnEmpty</code>) immediately</li>
</ul>

<p>Returns:</p>

<ul>
<li>the <code>hs.window.filter</code> object for method chaining</li>
</ul>

<p>Notes:</p>

<ul>
<li>If <code>fn</code> is nil, notifications for this windowfilter will stop.</li>
</ul>

            </td>
        </tr>
    </table>
    </section>


    <section id="pause">
    <a name="//apple_ref/cpp/Method/pause" class="dashAnchor"></a>
    <h5><a href="#pause">pause</a></h5>
    <table>
        <tr>
            <th>Signature</td>
            <td><code>hs.window.filter:pause() -> hs.window.filter object</code></td>
        </tr>
        <tr>
            <th>Type</td>
            <td>Method</td>
        </tr>
        <tr>
            <th>Description</td>
            <td>
                <p>Stops the windowfilter event subscriptions; no more event callbacks will be triggered, but the subscriptions remain intact for a subsequent call to <code>hs.window.filter:resume()</code></p>

<p>Parameters:</p>

<ul>
<li>None</li>
</ul>

<p>Returns:</p>

<ul>
<li>the <code>hs.window.filter</code> object for method chaining</li>
</ul>

            </td>
        </tr>
    </table>
    </section>


    <section id="rejectApp">
    <a name="//apple_ref/cpp/Method/rejectApp" class="dashAnchor"></a>
    <h5><a href="#rejectApp">rejectApp</a></h5>
    <table>
        <tr>
            <th>Signature</td>
            <td><code>hs.window.filter:rejectApp(appname) -> hs.window.filter object</code></td>
        </tr>
        <tr>
            <th>Type</td>
            <td>Method</td>
        </tr>
        <tr>
            <th>Description</td>
            <td>
                <p>Sets the windowfilter to outright reject any windows belonging to a specific app</p>

<p>Parameters:</p>

<ul>
<li>appname - app name as per <code>hs.application:name()</code></li>
</ul>

<p>Returns:</p>

<ul>
<li>the <code>hs.window.filter</code> object for method chaining</li>
</ul>

<p>Notes:</p>

<ul>
<li>this is just a convenience wrapper for <code>windowfilter:setAppFilter(appname,false)</code></li>
</ul>

            </td>
        </tr>
    </table>
    </section>


    <section id="resume">
    <a name="//apple_ref/cpp/Method/resume" class="dashAnchor"></a>
    <h5><a href="#resume">resume</a></h5>
    <table>
        <tr>
            <th>Signature</td>
            <td><code>hs.window.filter:resume() -> hs.window.filter object</code></td>
        </tr>
        <tr>
            <th>Type</td>
            <td>Method</td>
        </tr>
        <tr>
            <th>Description</td>
            <td>
                <p>Resumes the windowfilter event subscriptions</p>

<p>Parameters:</p>

<ul>
<li>None</li>
</ul>

<p>Returns:</p>

<ul>
<li>the <code>hs.window.filter</code> object for method chaining</li>
</ul>

            </td>
        </tr>
    </table>
    </section>


    <section id="setAppFilter">
    <a name="//apple_ref/cpp/Method/setAppFilter" class="dashAnchor"></a>
    <h5><a href="#setAppFilter">setAppFilter</a></h5>
    <table>
        <tr>
            <th>Signature</td>
            <td><code>hs.window.filter:setAppFilter(appname, filter) -> hs.window.filter object</code></td>
        </tr>
        <tr>
            <th>Type</td>
            <td>Method</td>
        </tr>
        <tr>
            <th>Description</td>
            <td>
                <p>Sets the detailed filtering rules for the windows of a specific app</p>

<p>Parameters:</p>

<ul>
<li>appname - app name as per <code>hs.application:name()</code></li>
<li>filter - if <code>false</code>, reject the app; if <code>true</code>, <code>nil</code>, or omitted, allow all visible windows (in any Space) for the app; otherwise
it must be a table describing the filtering rules for the app, via the following fields:

<ul>
<li>visible - if <code>true</code>, only allow visible windows (in any Space); if <code>false</code>, reject visible windows; if omitted, this rule is ignored</li>
<li>currentSpace - if <code>true</code>, only allow windows in the current Mission Control Space (minimized and hidden windows are included, as
they&#39;re considered to belong to all Spaces); if <code>false</code>, reject windows in the current Space (including all minimized and hidden windows);
if omitted, this rule is ignored</li>
<li>fullscreen - if <code>true</code>, only allow fullscreen windows; if <code>false</code>, reject fullscreen windows; if omitted, this rule is ignored</li>
<li>focused - if <code>true</code>, only allow a window while focused; if <code>false</code>, reject the focused window; if omitted, this rule is ignored</li>
<li>allowTitles

<ul>
<li>if a number, only allow windows whose title is at least as many characters long; e.g. pass <code>1</code> to filter windows with an empty title</li>
<li>if a string or table of strings, only allow windows whose title matches (one of) the pattern(s) as per <code>string.match</code></li>
<li>if omitted, this rule is ignored</li>
</ul></li>
<li>rejectTitles - if a string or table of strings, reject windows whose titles matches (one of) the pattern(s) as per <code>string.match</code>;
if omitted, this rule is ignored</li>
<li>allowRegions - an <code>hs.geometry</code> rect or constructor argument, or a list of them, designating (a) screen &quot;region(s)&quot; in absolute coordinates:
only allow windows that &quot;cover&quot; at least 50% of (one of) the region(s), and/or windows that have at least 50% of their surface inside
(one of) the region(s); if omitted, this rule is ignored</li>
<li>rejectRegions - an <code>hs.geometry</code> rect or constructor argument, or a list of them, designating (a) screen &quot;region(s)&quot; in absolute coordinates:
reject windows that &quot;cover&quot; at least 50% of (one of) the region(s), and/or windows that have at least 50% of their surface inside
(one of) the region(s); if omitted, this rule is ignored</li>
<li>allowScreens - a valid argument for <code>hs.screen.find()</code>, or a list of them, indicating one (or more) screen(s): only allow windows
that (mostly) lie on (one of) the screen(s); if omitted, this rule is ignored</li>
<li>rejectScreens - a valid argument for <code>hs.screen.find()</code>, or a list of them, indicating one (or more) screen(s): reject windows
that (mostly) lie on (one of) the screen(s); if omitted, this rule is ignored</li>
<li>allowRoles

<ul>
<li>if a string or table of strings, only allow these window roles as per <code>hs.window:subrole()</code></li>
<li>if the special string <code>&#39;*&#39;</code>, this rule is ignored (i.e. all window roles, including empty ones, are allowed)</li>
<li>if omitted, use the default allowed roles (defined in <code>hs.window.filter.allowedWindowRoles</code>)</li>
</ul></li>
</ul></li>
</ul>

<p>Returns:</p>

<ul>
<li>the <code>hs.window.filter</code> object for method chaining</li>
</ul>

<p>Notes:</p>

<ul>
<li>Passing <code>focused=true</code> in <code>filter</code> will (naturally) result in the windowfilter ever allowing 1 window at most</li>
<li>If you want to allow <em>all</em> windows for an app, including invisible ones, pass an empty table for <code>filter</code></li>
<li>Spaces-aware windowfilters might experience a (sometimes significant) delay after every Space switch, since
(due to OS X limitations) they must re-query for the list of all windows in the current Space every time.</li>
<li>If System Preferences&gt;Mission Control&gt;Displays have separate Spaces is <em>on</em>, the <em>current Space</em> is defined
as the union of all the Spaces that are currently visible</li>
<li>This table explains the effects of different combinations of <code>visible</code> and <code>currentSpace</code>, showing which windows will be allowed:</li>
</ul>

<pre><code>             |visible=         nil                      |             true             |     false    |
|currentSpace|------------------------------------------|------------------------------|--------------|
|     nil    |all                                       |visible in ANY space          |min and hidden|
|    true    |visible in CURRENT space+min and hidden   |visible in CURRENT space      |min and hidden|
|    false   |visible in OTHER space only+min and hidden|visible in OTHER space only   |none          |
</code></pre>

            </td>
        </tr>
    </table>
    </section>


    <section id="setCurrentSpace">
    <a name="//apple_ref/cpp/Method/setCurrentSpace" class="dashAnchor"></a>
    <h5><a href="#setCurrentSpace">setCurrentSpace</a></h5>
    <table>
        <tr>
            <th>Signature</td>
            <td><code>hs.window.filter:setCurrentSpace(val) -> hs.window.filter object</code></td>
        </tr>
        <tr>
            <th>Type</td>
            <td>Method</td>
        </tr>
        <tr>
            <th>Description</td>
            <td>
                <p>Sets whether the windowfilter should only allow (or reject) windows in the current Mission Control Space</p>

<p>Parameters:</p>

<ul>
<li>val - boolean; if <code>true</code>, only allow windows in the current Mission Control Space, plus minimized and hidden windows;
if <code>false</code>, reject them; if <code>nil</code>, ignore Mission Control Spaces</li>
</ul>

<p>Returns:</p>

<ul>
<li>the <code>hs.window.filter</code> object for method chaining</li>
</ul>

<p>Notes:</p>

<ul>
<li>This is just a convenience wrapper for setting the <code>currentSpace</code> field in the <code>override</code> filter (other
fields will be left untouched); per-app filters will maintain their <code>currentSpace</code> field, if present, as is</li>
<li>Spaces-aware windowfilters might experience a (sometimes significant) delay after every Space switch, since
(due to OS X limitations) they must re-query for the list of all windows in the current Space every time.</li>
</ul>

            </td>
        </tr>
    </table>
    </section>


    <section id="setDefaultFilter">
    <a name="//apple_ref/cpp/Method/setDefaultFilter" class="dashAnchor"></a>
    <h5><a href="#setDefaultFilter">setDefaultFilter</a></h5>
    <table>
        <tr>
            <th>Signature</td>
            <td><code>hs.window.filter:setDefaultFilter(filter) -> hs.window.filter object</code></td>
        </tr>
        <tr>
            <th>Type</td>
            <td>Method</td>
        </tr>
        <tr>
            <th>Description</td>
            <td>
                <p>Set the default filtering rules to be used for apps without app-specific rules</p>

<p>Parameters:</p>

<ul>
<li>filter - see <code>hs.window.filter:setAppFilter</code></li>
</ul>

<p>Returns:</p>

<ul>
<li>the <code>hs.window.filter</code> object for method chaining</li>
</ul>

            </td>
        </tr>
    </table>
    </section>


    <section id="setFilters">
    <a name="//apple_ref/cpp/Method/setFilters" class="dashAnchor"></a>
    <h5><a href="#setFilters">setFilters</a></h5>
    <table>
        <tr>
            <th>Signature</td>
            <td><code>hs.window.filter:setFilters(filters) -> hs.window.filter object</code></td>
        </tr>
        <tr>
            <th>Type</td>
            <td>Method</td>
        </tr>
        <tr>
            <th>Description</td>
            <td>
                <p>Sets multiple filtering rules</p>

<p>Parameters:</p>

<ul>
<li>filters - table, every element will set an application filter; these elements must:

<ul>
<li>have a <em>key</em> of type string, denoting an application name as per <code>hs.application:name()</code></li>
<li>if the <em>value</em> is a boolean, the app will be allowed or rejected accordingly - see <code>hs.window.filter:allowApp()</code>
and <code>hs.window.filter:rejectApp()</code></li>
<li>if the <em>value</em> is a table, it must contain the accept/reject rules for the app <em>as key/value pairs</em>; valid keys
and values are described in <code>hs.window.filter:setAppFilter()</code></li>
<li>the key can be one of the special strings <code>&quot;default&quot;</code> and <code>&quot;override&quot;</code>, which will will set the default and override
filter respectively</li>
<li>the key can be the special string <code>&quot;sortOrder&quot;</code>; the value must be one of the <code>sortBy...</code> constants as per
<code>hs.window.filter:setSortOrder()</code></li>
</ul></li>
</ul>

<p>Returns:</p>

<ul>
<li>the <code>hs.window.filter</code> object for method chaining</li>
</ul>

<p>Notes:</p>

<ul>
<li>every filter definition in <code>filters</code> will overwrite the pre-existing one for the relevant application, if present;
this also applies to the special default and override filters, if included</li>
</ul>

            </td>
        </tr>
    </table>
    </section>


    <section id="setOverrideFilter">
    <a name="//apple_ref/cpp/Method/setOverrideFilter" class="dashAnchor"></a>
    <h5><a href="#setOverrideFilter">setOverrideFilter</a></h5>
    <table>
        <tr>
            <th>Signature</td>
            <td><code>hs.window.filter:setOverrideFilter(filter) -> hs.window.filter object</code></td>
        </tr>
        <tr>
            <th>Type</td>
            <td>Method</td>
        </tr>
        <tr>
            <th>Description</td>
            <td>
                <p>Set overriding filtering rules that will be applied for all apps before any app-specific rules</p>

<p>Parameters:</p>

<ul>
<li>filter - see <code>hs.window.filter:setAppFilter</code></li>
</ul>

<p>Returns:</p>

<ul>
<li>the <code>hs.window.filter</code> object for method chaining</li>
</ul>

            </td>
        </tr>
    </table>
    </section>


    <section id="setRegions">
    <a name="//apple_ref/cpp/Method/setRegions" class="dashAnchor"></a>
    <h5><a href="#setRegions">setRegions</a></h5>
    <table>
        <tr>
            <th>Signature</td>
            <td><code>hs.window.filter:setRegions(regions) -> hs.window.filter object</code></td>
        </tr>
        <tr>
            <th>Type</td>
            <td>Method</td>
        </tr>
        <tr>
            <th>Description</td>
            <td>
                <p>Sets the allowed screen regions for this windowfilter</p>

<p>Parameters:</p>

<ul>
<li>regions - an <code>hs.geometry</code> rect or constructor argument, or a list of them, indicating the allowed region(s) for this windowfilter</li>
</ul>

<p>Returns:</p>

<ul>
<li>the <code>hs.window.filter</code> object for method chaining</li>
</ul>

<p>Notes:</p>

<ul>
<li>This is just a convenience wrapper for setting the <code>allowRegions</code> field in the <code>override</code> filter (other
fields will be left untouched); per-app filters will maintain their <code>allowRegions</code> and <code>rejectRegions</code> fields, if present</li>
</ul>

            </td>
        </tr>
    </table>
    </section>


    <section id="setScreens">
    <a name="//apple_ref/cpp/Method/setScreens" class="dashAnchor"></a>
    <h5><a href="#setScreens">setScreens</a></h5>
    <table>
        <tr>
            <th>Signature</td>
            <td><code>hs.window.filter:setScreens(screens) -> hs.window.filter object</code></td>
        </tr>
        <tr>
            <th>Type</td>
            <td>Method</td>
        </tr>
        <tr>
            <th>Description</td>
            <td>
                <p>Sets the allowed screens for this windowfilter</p>

<p>Parameters:</p>

<ul>
<li>regions - a valid argument for <code>hs.screen.find()</code>, or a list of them, indicating the allowed screen(s) for this windowfilter</li>
</ul>

<p>Returns:</p>

<ul>
<li>the <code>hs.window.filter</code> object for method chaining</li>
</ul>

<p>Notes:</p>

<ul>
<li>This is just a convenience wrapper for setting the <code>allowScreens</code> field in the <code>override</code> filter (other
fields will be left untouched); per-app filters will maintain their <code>allowScreens</code> and <code>rejectScreens</code> fields, if present</li>
</ul>

            </td>
        </tr>
    </table>
    </section>


    <section id="setSortOrder">
    <a name="//apple_ref/cpp/Method/setSortOrder" class="dashAnchor"></a>
    <h5><a href="#setSortOrder">setSortOrder</a></h5>
    <table>
        <tr>
            <th>Signature</td>
            <td><code>hs.window.filter:setSortOrder(sortOrder) -> hs.window.filter object</code></td>
        </tr>
        <tr>
            <th>Type</td>
            <td>Method</td>
        </tr>
        <tr>
            <th>Description</td>
            <td>
                <p>Sets the sort order for this windowfilter&#39;s <code>:getWindows()</code> method</p>

<p>Parameters:</p>

<ul>
<li>sortOrder - one of the <code>hs.window.filter.sortBy...</code> constants</li>
</ul>

<p>Returns:</p>

<ul>
<li>the <code>hs.window.filter</code> object for method chaining</li>
</ul>

<p>Notes:</p>

<ul>
<li>The default sort order for all windowfilters (that is, until changed by this method) is <code>hs.window.filter.sortByFocusedLast</code></li>
</ul>

            </td>
        </tr>
    </table>
    </section>


    <section id="subscribe">
    <a name="//apple_ref/cpp/Method/subscribe" class="dashAnchor"></a>
    <h5><a href="#subscribe">subscribe</a></h5>
    <table>
        <tr>
            <th>Signature</td>
            <td><code>hs.window.filter:subscribe(event, fn[, immediate]) -> hs.window.filter object</code></td>
        </tr>
        <tr>
            <th>Type</td>
            <td>Method</td>
        </tr>
        <tr>
            <th>Description</td>
            <td>
                <p>Subscribe to one or more events on the allowed windows</p>

<p>Parameters:</p>

<ul>
<li>event - string or list of strings, the event(s) to subscribe to (see the <code>hs.window.filter</code> constants);
alternatively, this can be a map <code>{event1=fn1,event2=fn2,...}</code>: fnN will be subscribed to eventN, and the parameter <code>fn</code> will be ignored</li>
<li>fn - function or list of functions, the callback(s) to add for the event(s); each will be passed 3 parameters

<ul>
<li>a <code>hs.window</code> object referring to the event&#39;s window</li>
<li>a string containing the application name (<code>window:application():name()</code>) for convenience</li>
<li>a string containing the event that caused the callback, i.e. (one of) the event(s) you subscribed to</li>
</ul></li>
<li>immediate - (optional) if <code>true</code>, also call all the callbacks immediately for windows that satisfy the event(s) criteria</li>
</ul>

<p>Returns:</p>

<ul>
<li>the <code>hs.window.filter</code> object for method chaining</li>
</ul>

<p>Notes:</p>

<ul>
<li>Passing lists means that <em>all</em> the <code>fn</code>s will be called when <em>any</em> of the <code>event</code>s fires,
so it&#39;s <em>not</em> a shortcut for subscribing distinct callbacks to distinct events; use a map
or chained <code>:subscribe</code> calls for that.</li>
<li>Use caution with <code>immediate</code>: if for example you&#39;re subscribing to <code>hs.window.filter.windowUnfocused</code>,
<code>fn</code>(s) will be called for <em>all</em> the windows except the currently focused one.</li>
<li>If the windowfilter was paused with <code>hs.window.filter:pause()</code>, calling this will resume it.</li>
</ul>

            </td>
        </tr>
    </table>
    </section>


    <section id="unsubscribe">
    <a name="//apple_ref/cpp/Method/unsubscribe" class="dashAnchor"></a>
    <h5><a href="#unsubscribe">unsubscribe</a></h5>
    <table>
        <tr>
            <th>Signature</td>
            <td><code>hs.window.filter:unsubscribe([event][, fn]) -> hs.window.filter object</code></td>
        </tr>
        <tr>
            <th>Type</td>
            <td>Method</td>
        </tr>
        <tr>
            <th>Description</td>
            <td>
                <p>Removes one or more event subscriptions</p>

<p>Parameters:</p>

<ul>
<li>event - string or list of strings, the event(s) to unsubscribe; if omitted, <code>fn</code>(s) will be unsubscribed from all events;
alternatively, this can be a map <code>{event1=fn1,event2=fn2,...}</code>: fnN will be unsubscribed from eventN, and the parameter <code>fn</code> will be ignored</li>
<li>fn - function or list of functions, the callback(s) to remove; if omitted, all callbacks will be unsubscribed from <code>event</code>(s)</li>
</ul>

<p>Returns:</p>

<ul>
<li>the <code>hs.window.filter</code> object for method chaining</li>
</ul>

<p>Notes:</p>

<ul>
<li>You must pass at least one of <code>event</code> or <code>fn</code></li>
<li>If calling this on the default (or any other shared use) windowfilter, do not pass events, as that would remove
<em>all</em> the callbacks for the events including ones subscribed elsewhere that you might not be aware of. You should
instead keep references to your functions and pass in those.</li>
</ul>

            </td>
        </tr>
    </table>
    </section>


    <section id="unsubscribeAll">
    <a name="//apple_ref/cpp/Method/unsubscribeAll" class="dashAnchor"></a>
    <h5><a href="#unsubscribeAll">unsubscribeAll</a></h5>
    <table>
        <tr>
            <th>Signature</td>
            <td><code>hs.window.filter:unsubscribeAll() -> hs.window.filter object</code></td>
        </tr>
        <tr>
            <th>Type</td>
            <td>Method</td>
        </tr>
        <tr>
            <th>Description</td>
            <td>
                <p>Removes all event subscriptions</p>

<p>Parameters:</p>

<ul>
<li>None</li>
</ul>

<p>Returns:</p>

<ul>
<li>the <code>hs.window.filter</code> object for method chaining</li>
</ul>

<p>Notes:</p>

<ul>
<li>You should not use this on the default windowfilter or other shared-use windowfilters</li>
</ul>

            </td>
        </tr>
    </table>
    </section>


    <section id="windowsToEast">
    <a name="//apple_ref/cpp/Method/windowsToEast" class="dashAnchor"></a>
    <h5><a href="#windowsToEast">windowsToEast</a></h5>
    <table>
        <tr>
            <th>Signature</td>
            <td><code>hs.window.filter:windowsToEast(window, frontmost, strict) -> list of `hs.window` objects</code></td>
        </tr>
        <tr>
            <th>Type</td>
            <td>Method</td>
        </tr>
        <tr>
            <th>Description</td>
            <td>
                <p>Gets all visible windows allowed by this windowfilter that lie to the east a given window</p>

<p>Parameters:</p>

<ul>
<li>window - (optional) an <code>hs.window</code> object; if nil, <code>hs.window.frontmostWindow()</code> will be used</li>
<li>frontmost - (optional) boolean, if true unoccluded windows will be placed before occluded ones in the result list</li>
<li>strict - (optional) boolean, if true only consider windows at an angle between 45° and -45° on the
eastward axis</li>
</ul>

<p>Returns:</p>

<ul>
<li>A list of <code>hs.window</code> objects representing all windows positioned east (i.e. right) of the window, in ascending order of distance</li>
</ul>

<p>Notes:</p>

<ul>
<li>This is a convenience wrapper that returns <code>hs.window.windowsToEast(window,self:getWindows(),...)</code></li>
</ul>

            </td>
        </tr>
    </table>
    </section>


    <section id="windowsToNorth">
    <a name="//apple_ref/cpp/Method/windowsToNorth" class="dashAnchor"></a>
    <h5><a href="#windowsToNorth">windowsToNorth</a></h5>
    <table>
        <tr>
            <th>Signature</td>
            <td><code>hs.window.filter:windowsToNorth(window, frontmost, strict) -> list of `hs.window` objects</code></td>
        </tr>
        <tr>
            <th>Type</td>
            <td>Method</td>
        </tr>
        <tr>
            <th>Description</td>
            <td>
                <p>Gets all visible windows allowed by this windowfilter that lie to the north a given window</p>

<p>Parameters:</p>

<ul>
<li>window - (optional) an <code>hs.window</code> object; if nil, <code>hs.window.frontmostWindow()</code> will be used</li>
<li>frontmost - (optional) boolean, if true unoccluded windows will be placed before occluded ones in the result list</li>
<li>strict - (optional) boolean, if true only consider windows at an angle between 45° and -45° on the
northward axis</li>
</ul>

<p>Returns:</p>

<ul>
<li>A list of <code>hs.window</code> objects representing all windows positioned north (i.e. up) of the window, in ascending order of distance</li>
</ul>

<p>Notes:</p>

<ul>
<li>This is a convenience wrapper that returns <code>hs.window.windowsToNorth(window,self:getWindows(),...)</code></li>
</ul>

            </td>
        </tr>
    </table>
    </section>


    <section id="windowsToSouth">
    <a name="//apple_ref/cpp/Method/windowsToSouth" class="dashAnchor"></a>
    <h5><a href="#windowsToSouth">windowsToSouth</a></h5>
    <table>
        <tr>
            <th>Signature</td>
            <td><code>hs.window.filter:windowsToSouth(window, frontmost, strict) -> list of `hs.window` objects</code></td>
        </tr>
        <tr>
            <th>Type</td>
            <td>Method</td>
        </tr>
        <tr>
            <th>Description</td>
            <td>
                <p>Gets all visible windows allowed by this windowfilter that lie to the south a given window</p>

<p>Parameters:</p>

<ul>
<li>window - (optional) an <code>hs.window</code> object; if nil, <code>hs.window.frontmostWindow()</code> will be used</li>
<li>frontmost - (optional) boolean, if true unoccluded windows will be placed before occluded ones in the result list</li>
<li>strict - (optional) boolean, if true only consider windows at an angle between 45° and -45° on the
southward axis</li>
</ul>

<p>Returns:</p>

<ul>
<li>A list of <code>hs.window</code> objects representing all windows positioned south (i.e. down) of the window, in ascending order of distance</li>
</ul>

<p>Notes:</p>

<ul>
<li>This is a convenience wrapper that returns <code>hs.window.windowsToSouth(window,self:getWindows(),...)</code></li>
</ul>

            </td>
        </tr>
    </table>
    </section>


    <section id="windowsToWest">
    <a name="//apple_ref/cpp/Method/windowsToWest" class="dashAnchor"></a>
    <h5><a href="#windowsToWest">windowsToWest</a></h5>
    <table>
        <tr>
            <th>Signature</td>
            <td><code>hs.window.filter:windowsToWest(window, frontmost, strict) -> list of `hs.window` objects</code></td>
        </tr>
        <tr>
            <th>Type</td>
            <td>Method</td>
        </tr>
        <tr>
            <th>Description</td>
            <td>
                <p>Gets all visible windows allowed by this windowfilter that lie to the west a given window</p>

<p>Parameters:</p>

<ul>
<li>window - (optional) an <code>hs.window</code> object; if nil, <code>hs.window.frontmostWindow()</code> will be used</li>
<li>frontmost - (optional) boolean, if true unoccluded windows will be placed before occluded ones in the result list</li>
<li>strict - (optional) boolean, if true only consider windows at an angle between 45° and -45° on the
westward axis</li>
</ul>

<p>Returns:</p>

<ul>
<li>A list of <code>hs.window</code> objects representing all windows positioned west (i.e. left) of the window, in ascending order of distance</li>
</ul>

<p>Notes:</p>

<ul>
<li>This is a convenience wrapper that returns <code>hs.window.windowsToWest(window,self:getWindows(),...)</code></li>
</ul>

            </td>
        </tr>
    </table>
    </section>

  </body>
</html>
