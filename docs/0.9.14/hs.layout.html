<html>
  <head>
    <title>Hammerspoon docs: hs.layout module</title>
    <style type="text/css">
      a { text-decoration: none; }
      a:hover { text-decoration: underline; }
      header { padding-bottom: 50px; }
      section { border-top: 1px solid #777; padding-bottom: 20px; }
    </style>
    <link rel="stylesheet" href="docs.css" type="text/css" media="screen" />
  </head>
  <body>
    <header>
      <h1>hs.layout</h1>
      <p>Window layout manager</p>

<p>This extension allows you to trigger window placement/sizing to a number of windows at once</p>

    </header>
    
    <section id="apply">
      <a name="//apple_ref/cpp/Function/apply" class="dashAnchor"></a>
      <h3><a href="#apply">apply</a></h3>
      <code>hs.layout.apply(table)</code>
      <p>Applies a layout to applications/windows<br>
To use this function, pass in a table containing rules that describe your layout, for example:</p>

<pre><code>layout1 = {
  {&quot;Mail&quot;, nil, &quot;Color LCD&quot;, hs.layout.maximized, nil, nil},
  {&quot;Safari&quot;, nil, &quot;Thunderbolt Display&quot;, hs.layout.maximized, nil, nil},
  {&quot;iTunes&quot;, &quot;iTunes&quot;, &quot;Color LCD&quot;, hs.layout.maximized, nil, nil},
  {&quot;iTunes&quot;, &quot;MiniPlayer&quot;, &quot;Color LCD&quot;, nil, nil, hs.geometry.rect(0, -48, 400, 48)},
}
</code></pre>

<p>The fields in each line of the table are:</p>

<ul>
<li>Application name or nil</li>
<li>Window title or nil</li>
<li>Monitor name</li>
<li>Unit rect</li>
<li>Frame rect</li>
<li>Full-frame rect</li>
</ul>

<p>If the application name argument is nil, window titles will be matched regardless of which app they belong to<br>
If the window title argument is nil, all windows of the specified application will be matched<br>
You can specify both application name and window title if you want to match only one window of a particular application.<br>
If you specify neither application name or window title, no windows will be matched :)</p>

<p>Monitor name is a string, as found in hs.screen:name()</p>

<p>The final three arguments use hs.geometry.rect() objects to describe the desired position and size of matched windows:</p>

<ul>
<li>Unit rect will be passed to hs.window.moveToUnit()</li>
<li>Frame rect will be passed to hs.window.setFrame() (including menubar and dock)</li>
<li>Full-frame rect will be passed to hs.window.setFrame() (ignoring menubar and dock)</li>
</ul>

<p>If either the x or y components of frame/full-frame rect are negative, they will be applied as offsets against the opposite<br>
edge of the screen (e.g. If x is -100 then the left edge of the window will be 100 pixels from the right edge of the screen).</p>

<p>Note that only one of the rect arguments will apply to any matched windows. If you specify more than one, the first will win.</p>

<p>There are various pre-defined rects that can be passed as the Unit rect argument:</p>

<ul>
<li>hs.apply.maximized - window will occupy all of the screen</li>
<li>hs.apply.left25 - window will occupy the left 25% of the screen</li>
<li>hs.apply.left30 - window will occupy the left 30% of the screen</li>
<li>hs.apply.left50 - window will occupy the left half of the screen</li>
<li>hs.apply.left70 - window will occupy the left 70% of the screen</li>
<li><p>hs.apply.left75 - window will occupy the left 75% of the screen</p>

<p>(the above options are also available with &#39;right&#39; equivalents)</p></li>
</ul>

    </section>
    
  </body>
</html>
